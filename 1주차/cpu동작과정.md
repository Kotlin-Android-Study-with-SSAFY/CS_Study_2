# 1주차 - 중앙처리장치(CPU)의 작동 원리

- 참고 사이트 : https://sunyoung-00.tistory.com/55

# **🔹 중앙처리장치 (CPU)란?**

### **📌 Central Processing Unit (중앙처리장치)**

- 주기억장치(메모리)에서 명령어를 읽어 들이고 이를 해석하여 수행하는 작업을 담당하는 장치.
- 주요 구성 요소:
    - **ALU (Arithmetic Logic Unit, 산술 논리 연산 장치)**
        - 산술 및 논리 연산을 수행.
        - 연산에 필요한 데이터를 레지스터에서 가져오고 결과를 다시 레지스터로 보냄.
    - **CU (Control Unit, 제어 장치)**
        - 명령어의 순서와 수행을 제어하는 역할.
    - **Register (레지스터)**
        - 중간 결과와 작업 상태를 저장하는 작은 용량의 메모리.
        - 여러 개의 레지스터로 구성된 **레지스터 파일(Register File)** 형태로 존재.

---

# **📌 레지스터의 역할**

### 🔹 **범용 레지스터 (General Purpose Register)**

- 연산에 필요한 데이터나 연산 결과를 임시로 저장.

### 🔹 **특수 목적 레지스터 (Special Purpose Register)**

| 레지스터 | 역할 |
| --- | --- |
| **MAR** (Memory Address Register) | 읽기 및 쓰기 연산을 수행할 메인 메모리 주소 저장 |
| **PC** (Program Counter) | 다음에 수행할 명령어의 메모리 주소 저장 |
| **IR** (Instruction Register) | 현재 실행 중인 명령어 저장 |
| **MBR** (Memory Buffer Register) | 메모리에서 읽은 데이터 or 저장할 데이터 임시 저장. MDR ( Memory Data Regiser) 라고 표현하기도 한다. |
| **AC** (Accumulator) | 연산 결과 임시 저장 |

---

# **📌 제어 유닛 (CU, Control Unit)의 역할**

- **명령어 해석** → 어떤 연산을 수행할지 결정
- **제어 신호 생성** → ALU와 레지스터에 적절한 신호 전달
- **데이터 흐름 관리** → 메모리, 레지스터, ALU 간 데이터 흐름 조정
- **조건 분기 및 제어 흐름 관리** → 조건문과 반복문 제어

---

# **📌 명령어 사이클 (Instruction Cycle)**

> CPU가 프로그램을 실행하는 기본 단위
> 
> 
> `Fetch → Decode → Execute → Store` 순서로 수행됨.
> 

### **🔹 1. 인출 사이클 (Fetch Cycle)**

- **CPU가 프로그램 카운터(PC)가 가리키는 메모리 주소에서 명령어를 가져옴.**
- **PC 값 증가** (다음 명령어를 가리키도록 업데이트됨).

### **🔹 2. 디코딩 사이클 (Decoding Cycle)**

- **가져온 명령어를 해석하여 실행할 수 있도록 분석.**
- CPU가 **명령어가 무엇인지 파악**하고, **필요한 연산자 및 데이터를 준비**함.

### **🔹 3. 실행 사이클 (Execute Cycle)**

- **해독된 명령어를 실제로 실행** (ALU 연산 수행, 메모리 접근 등).

### **🔹 4. 저장 사이클 (Store Cycle)**

- **연산 결과를 필요에 따라 메모리에 저장** (또는 특정 레지스터에 저장).

---

## **📌 간접 사이클 (Indirect Cycle)**

- **명령어에 사용될 데이터가 레지스터가 아니라 메모리 주소에 저장되어 있는 경우, 해당 메모리에 접근해야 하는 추가 사이클.**
- **직접 주소 지정(Direct Addressing)** 방식이 아니라 **간접 주소 지정(Indirect Addressing)** 방식에서 발생.
- 데이터를 가져오기 위해 **한 번 더 메모리 접근이 필요**하여 실행 속도가 느려질 수 있음.

---

# **📌 사이클 별 동작 매커니즘**

## **1️⃣ 명령어 인출 사이클 (Fetch Cycle)**

 CPU가 메모리에서 다음에 실행할 명령어를 가져오는 과정이다.

1. **PC(Program Counter)가 다음 실행할 명령어의 주소를 가리킴**
    - 예: `PC = 0x1000` (명령어가 저장된 주소)
2. **MAR(Memory Address Register)에 PC 값을 저장 → MAR이 메모리에서 해당 주소를 요청**
    - `MAR = 0x1000`
    - CPU가 이 주소에서 명령어를 가져오도록 메모리에 요청
3. **메모리에서 명령어를 읽어와 MDR(Memory Data Register)에 저장**
    - 예제 명령어: `MDR = "ADD R1, R2"`
4. **MDR의 내용을 IR(Instruction Register)에 복사**
    - `IR = "ADD R1, R2"`
    - 이제 CPU가 명령어를 해석하고 실행할 준비가 완료됨
5. **PC 증가 (다음 명령어 준비)**
    - `PC = 0x1004` (다음 명령어가 있는 주소로 이동)

---

## **2️⃣ 명령어 해독 사이클 (Decoding Cycle)**

CPU가 가져온 명령어를 분석하는 과정이다.

1. **IR의 값을 해독기(Decoder)로 전달하여 분석**
    - 예: `IR = "ADD R1, R2"`
    - CPU가 해당 명령어가 "덧셈 연산(ADD)"을 수행해야 한다는 것을 파악
2. **연산 코드(OpCode)와 피연산자(Operands) 분리**
    - 예: `OpCode = "ADD"`, `Operand1 = "R1"`, `Operand2 = "R2"`
3. **필요한 레지스터 및 연산 준비**
    - R1과 R2의 값을 ALU(Arithmetic Logic Unit)로 로드
    - 제어 장치(Control Unit)가 해당 명령어를 실행하기 위한 신호 생성

---

## **3️⃣ 명령어 실행 사이클 (Execute Cycle)**

명령어가 실제로 수행되는 과정이다.

1. **ALU가 연산 수행**
    - 예: `R1 = R1 + R2`
    - 만약 `R1 = 5`, `R2 = 3`이었다면, `R1 = 8`로 변경됨
2. **조건부 연산 처리 (예: 분기, 조건문 등)**
    - 예를 들어, `JUMP`나 `IF` 명령어가 있다면 프로그램 흐름을 변경
3. **결과를 필요한 곳에 저장할 준비**

---

## **4️⃣ 저장 사이클 (Store Cycle)**

실행된 연산 결과를 다시 레지스터나 메모리에 저장하는 과정이다.

1. **연산 결과를 레지스터 또는 메모리에 저장**
    - `R1 = 8` (ADD 연산 결과가 저장됨)
    - 필요에 따라 메모리(`MAR` 주소)에 값을 저장할 수도 있음
2. **필요하다면 상태 플래그(Status Flags) 갱신**
    - 예: 오버플로우 발생 여부, 제로 플래그(연산 결과가 0인지 여부) 등
3. **다음 명령어 실행 준비**
    - 제어 장치가 다음 명령어를 실행할 수 있도록 명령어 사이클 반복
    

---

## **🚀 파이프라이닝(Pipelining) 이란?**

CPU의 명령어 사이클(Instruction Cycle)은 기본적으로 다음 4단계로 나뉩니다:

1. **Fetch** (명령어 가져오기)
2. **Decode** (명령어 해독)
3. **Execute** (명령어 실행)
4. **Store** (결과 저장)

보통 이 단계를 **순차적으로 하나씩 실행하면 CPU의 성능이 떨어지지만**,

**파이프라이닝을 사용하면 여러 개의 명령어를 겹쳐서 실행**할 수 있습니다.

### **🔹 예제: 파이프라이닝 없이 순차 실행**

- 클럭 사이클(Clock Cycle)이 4개 필요함. (1개 명령어 처리에 4 사이클)

| 클럭 사이클 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 명령어1 | Fetch | Decode | Execute | Store |  |  |  |  |  |  |
| 명령어2 |  |  |  |  | Fetch | Decode | Execute | Store |  |  |
| 명령어3 |  |  |  |  |  |  |  |  | Fetch | Decode |

### **🔹 예제: 파이프라이닝 적용 (동시 실행)**

- 1개 명령어를 완료하는 데 여전히 4 사이클이 필요하지만, **여러 개의 명령어를 겹쳐 실행하여 총 실행 시간이 줄어듦!**

| 클럭 사이클 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 명령어1 | Fetch | Decode | Execute | Store |  |  |  |  |  |  |
| 명령어2 |  | Fetch | Decode | Execute | Store |  |  |  |  |  |
| 명령어3 |  |  | Fetch | Decode | Execute | Store |  |  |  |  |
| 명령어4 |  |  |  | Fetch | Decode | Execute | Store |  |  |  |

✅ **결과:** 파이프라이닝을 사용하면 CPU는 **매 클럭마다 새로운 명령어를 실행 가능**

✅ **처리 속도 증가:** 총 10개 클럭에서 2개의 명령어만 실행하던 것이 4개 실행됨.

---

## **🚀 2. 클럭(Clock)과의 관계**

### **🔹 클럭(Clock)이란?**

CPU는 **클럭(Clock) 신호**에 맞춰 동작합니다.

클럭은 일정한 주기로 HIGH(1) → LOW(0) 신호를 반복하는 **진동자(oscillator) 신호**이며, 이를 통해 CPU 내부의 연산 속도를 결정합니다.

클럭은 CPU 내부의 전자 회로가 동작하는 기준이 되는 주기적인 신호이다.

- **클럭 속도(Clock Speed)**: CPU가 1초에 몇 번의 클럭 신호를 받는지를 의미함.
    - 단위: Hz (Hertz) 또는 GHz (Gigahertz)
    - 예: 3.5GHz CPU → 초당 35억(3,500,000,000)번 클럭 발생

### **🔹 클럭 주기와 파이프라이닝**

- 클럭 주기(Clock Cycle)는 **CPU가 한 번의 연산을 수행하는 데 필요한 최소 시간 단위**.
- CPU는 매 클럭마다 **파이프라인의 다음 단계로 진행**.
- 따라서 **클럭 주기가 짧을수록(클럭 속도가 빠를수록), 파이프라이닝의 효과가 극대화**

---

## **🚀 3. 파이프라이닝의 한계점**

### **🔹 1️⃣ 데이터 해저드(Data Hazard)**

- 연산 결과가 다음 명령어에서 필요할 경우 발생.
- 예: `R1 = R2 + R3` 후에 `R4 = R1 + 5` 실행 시, `R1`이 완전히 계산되기 전에 `R4`가 필요할 수 있음.

```nasm
ADD R1, R2, R3  # R1 = R2 + R3 (ALU 연산)
SUB R4, R1, R5  # R4 = R1 - R5 (R1의 값이 필요함!)
```

### **🚀 데이터 해저드 발생 시 클럭 사이클**

| 클럭 사이클 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **ADD R1, R2, R3** | Fetch | Decode | Execute | Memory | **Write Back** |  |  |
| **SUB R4, R1, R5** |  | Fetch | Decode | **Execute (R1 필요!) ❌** | Stall | **Execute** | Write Ba |

✅  `SUB` 명령어가 **클럭 4에서 실행(Execute) 단계에 들어감.**

✅ 하지만, `ADD` 명령어가 아직 클럭 5에서 **R1 값을 Write Back하는 중**

✅ **즉, `SUB` 명령어가 클럭 4에서 R1을 가져오려 하지만 값이 아직 없음**

✅ 이로 인해 **STALL(대기)** 발생

- 해결책: **포워딩(Forwarding) 기법 사용** (연산 결과를 미리 다음 단계로 넘겨줌).

---

**🔹 2️⃣ 제어 해저드(Control Hazard)**

- **분기(Branch) 명령어 실행 시, 파이프라인에 있는 기존 명령어가 무효화되는 문제**.
- 예: `if (A > B) jump X;` → 조건에 따라 다른 주소로 점프하면, 파이프라인에 남아 있던 명령어가 필요 없어짐.

```nasm
BEQ R1, R2, LABEL  # 만약 R1 == R2이면 LABEL로 점프
ADD R3, R4, R5      # (점프 안 하면 실행될 명령어)
SUB R6, R7, R8      # (점프 안 하면 실행될 명령어)
LABEL: MUL R9, R10, R11  # (점프하면 실행될 명령어)
```

| 클럭 사이클 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **BEQ R1, R2, LABEL** | Fetch | Decode | Execute | 🛑 (분기 결정) |  |  |  |
| **ADD R3, R4, R5** |  | Fetch | Decode | 🛑 무효화(Flush) |  |  |  |
| **SUB R6, R7, R8** |  |  | Fetch | 🛑 무효화(Flush) |  |  |  |
| **MUL R9, R10, R11 (분기된 명령어)** |  |  |  | Fetch | Decode | Execute | Store |

✅ BEQ 명령어가 실행될 때까지(4 클럭째), CPU는 이미 다음 명령어(ADD, SUB)를 가져왔음.

✅ 분기가 발생하면 ADD, SUB는 필요 없는 명령어가 되어 무효화됨 (Flush).

✅ 결과적으로 파이프라인이 2~3클럭 동안 멈추는 현상이 발생

- 해결책: **분기 예측(Branch Prediction) 기법 사용** (CPU가 미리 예측하여 실행).
    - 정적 분기 예측 - 항상 분기가 발생한다고 가정 or 그렇지 않다고 가정.
    - 동적 분기 예측 - CPU가 이전 분기 결과를 학습하여 다음 분기 예측
    - 지연 분기 - 분기 명령어 이후에도 몇 개의 임의의 명령어는 항상 실행되도록

---

### **🔹 3️⃣ 구조적 해저드(Structural Hazard**

- 특정 하드웨어 리소스를 동시에 사용해야 하는 경우 충돌이 발생.
- 예: ALU가 연산을 수행하는 동안, 동시에 다른 명령어도 ALU를 사용하려고 하면 충돌 발생.

| 클럭 사이클 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 명령어 1 | Fetch | Decode | **Execute (ALU 1/3)** | **Execute (ALU 2/3)** | **Execute (ALU 3/3)** | Store |  |  |  |  |
| 명령어 2 |  | Fetch | Decode | **Execute (ALU 1/3)** | **Execute (ALU 2/3)** | **Execute (ALU 3/3)** | Store |  |  |  |
| 명령어 3 |  |  | Fetch | Decode | **Execute (ALU 1/3)** | **Execute (ALU 2/3)** | **Execute (ALU 3/3)** | Store |  |  |

✅ **명령어 1이 ALU를 3 클럭 동안 사용하므로, 명령어 2와 명령어 3이 실행될 때 ALU를 동시에 사용하려고 함**

- 해결책: 한 클럭 사이클 **stall**  시킨다.
