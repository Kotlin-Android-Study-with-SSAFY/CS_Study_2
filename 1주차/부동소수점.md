# 4️⃣ 고정 소수점 & 부동 소수점

> **💡 컴퓨터가 실수를 표현하는 방법**
>
> 컴퓨터는 수를 표현할 때 0과 1로 표현한다. 그렇다면 소수점이 붙어있는 수는 어떻게 표현할까?

---

## 🛠️ 고정소수점 (Fixed Point)

**💡 10진수를 2진수로 변환하여 그대로 저장**

- 정수부와 소수부를 나누는 소수점의 위치가 **고정됨**

### ✅ 변환 과정
1. 10진수를 2진수로 변환
    - 예: `7.625 → 111.101`
2. 부호비트 (Sign Bit)
    - 양수이면 `0`, 음수이면 `1`
3. 정수부
    - 정수 부분을 저장하고, 남는 앞자리는 `0`으로 채움
4. 소수부
    - 소수 부분을 저장하고, 남는 뒷자리는 `0`으로 채움

### ✅ 특징
- **장점:** 구현이 간단하고 빠름
- **단점:** 표현 가능한 수의 범위가 제한적임

---

## 🌊 부동소수점 (Floating Point)

**💡 10진수를 2진수로 변환한 결과에 정규화 과정을 거쳐 저장**

- **浮(뜰 부) 動(움직일 동)** → 표현하고자 하는 수의 크기에 따라 **소수점이 떠서 움직임**

### ✅ 정규화 (Normalization)

**💡 2진수를 `1.xxxx… * 2^n` 꼴로 변환하는 과정**

```
111.101 → 1.11101 * 2^2
```

- 정수부에 `1`만 남을 때까지 소수점을 이동
- 이동한 칸 수만큼 `n`을 조정

### ✅ 변환 과정
1. 10진수를 2진수로 변환 후 정규화
    - `7.625 → 111.101 → 1.11101 * 2^2`
2. 부호비트 (Sign Bit)
    - 양수이면 `0`, 음수이면 `1`
3. 지수부 (Exponent)
    - 지수에 `bias`를 더하여 저장 (32비트 기준 `bias = 127`)
4. 가수부 (Mantissa)
    - 정규화 후 소수점 오른쪽 숫자들만 저장 (정수 `1`은 생략)

### 📌 IEEE 754 표준

> **💡 IEEE에서 개발한 부동소수점 표현 표준**
> - `±0`, `무한대`, `NaN` 등의 기호를 표시하는 법과 연산 규칙이 정의됨

---

## 🔥 단정도 vs 배정도

### 📌 단정도 (Single Precision)
- **32비트 사용 (float)**
- `부호(1) + 지수(8) + 가수(23)`
- 표현 범위: `-3.4 x 10^38 ~ 3.4 x 10^38`

### 📌 배정도 (Double Precision)
- **64비트 사용 (double)**
- `부호(1) + 지수(11) + 가수(52)`
- 표현 범위: `-1.8 x 10^308 ~ 1.8 x 10^308`

---

## 🎯 부동 소수점 연산 오차

### 1️⃣ 반올림 오차 (Rounding Error)
- 부동 소수점은 유한한 비트로 표현되므로 **정확한 값을 저장할 수 없음**
- 예: `0.1`은 2진수로 정확히 표현할 수 없어 근사값으로 저장됨

### 2️⃣ 누적 오차 (Accumulation Error)
- 작은 오차가 반복되는 연산을 거치면서 점점 커짐

```java
for (int i = 0; i < 100; i++) {
    sum += 0.1f;
}
System.out.println(sum); // 9.9999999998
```

### 3️⃣ 소실 오차 (Loss of Significance)
- 큰 값에서 작은 값을 뺄 때, 유효 숫자가 줄어들어 정밀도가 떨어짐

```
1.0000001 - 1.0000000 = 0.0000001
```

### 4️⃣ 연산 순서에 따른 오차 (Order of Operations Error)
- 부동 소수점 연산은 **결합법칙이 성립하지 않음**
- `(a+b)+c ≠ a+(b+c)`

---

## 🛠️ 오차 줄이는 법

1. `float`보다는 `double` 사용
2. 실수를 정수로 바로 캐스팅하지 않기
3. 비교 연산 시 등호(==) 사용 지양

### ✅ 오차 해결법

#### 🔹 정수 연산 활용 (Java)
```java
int a = 10;
int b = 20;
int sum = a + b;
System.out.println(sum / 10.0); // 0.3
```

#### 🔹 Python - Decimal 활용
```python
from decimal import Decimal
a = Decimal('0.1')
b = Decimal('0.2')
print(a + b)  # 0.3
```

#### 🔹 Java - BigDecimal 활용
```java
import java.math.BigDecimal;

BigDecimal num1 = new BigDecimal("0.1");
BigDecimal num2 = new BigDecimal("0.2");
System.out.println(num1.add(num2)); // 0.3
```

#### 🔹 JavaScript - Big.js 활용
```js
const Big = require('big.js');
let a = new Big('0.1');
let b = new Big('0.2');
console.log(a.plus(b).toString()); // 0.3
```

---

## 🌡️ 언더플로우 & 오버플로우 (Underflow & Overflow)

### ✅ 원인
- **오버플로우:** 너무 큰 수를 표현하려다 **범위를 초과**하는 경우
- **언더플로우:** 너무 작은 수를 표현하려다 **0으로 수렴**하는 경우

### ✅ 해결 방법
1. **범위 검사** - 연산 전에 값이 범위를 벗어나는지 체크
2. **데이터 타입 확장** - 필요 시 더 큰 범위를 지원하는 데이터 타입 사용 (float → double)
3. **Math.addExact 활용 (Java)**

```java
try {
    int result = Math.addExact(Integer.MAX_VALUE, 1);
} catch (ArithmeticException e) {
    System.out.println("Overflow detected!");
}
```

---

## ⚡ Denormalized Number (비정규화 수)

### ✅ 특징
- `0.xxxx * 2^n` 형태로 표현됨
- 극도로 작은 숫자를 표현 가능 → **언더플로우 방지**

### ✅ 장점
- 정규화된 수와 0 사이에 부드럽게 작은 값 표현 가능

### ❌ 단점
- **연산 속도 저하** (CPU 성능 저하 유발)
- **전력 소비 증가**
- **FPU에서 예외 처리 필요**

💡 **고성능 연산에서는 비정규화 숫자를 피하는 것이 유리!** 🚀

