# 2️⃣ 페이징 & 세그멘테이션

## 💾 메모리

### 📌 메인 메모리

- CPU가 직접 접근할 수 있는 기억장치
- 프로세스가 실행되려면 프로그램 코드를 메인메모리에 적재해야 한다
- 모든 프로그램 코드를 물리 메모리에 올릴 수는 없다!
<br>

### 📌 가상 메모리

- 실제 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것
- 메모리의 공간은 한정적이므로 사용자에게 더 많은 메모리를 제공하기 위해 가상 주소 사용
- **물리주소** : 메모리의 하드웨어 상 실제 주소
- **논리주소** : 프로세스마다 부여되는 0번지부터 시작하는 주소체계, 중복되는 번지 수 존재 가능
- **메모리 관리 장치 (MMU)** : CPU가 이해하는 논리주소를 메모리가 이해하는 물리주소로 변환하는 역할

![image](https://github.com/user-attachments/assets/a2f3a0b1-5674-46a1-93b5-1e3a7082b5a7)

<br>

---

<br>

## 💼 메모리 할당 방식

### 📌 스와핑 Swapping

- 현재 실행되고 있지 않은 프로세스를 메모리에서 쫓아내고, 빈 공간에 다른 프로세스를 적재하여 실행하는 메모리 관리 방식
- 보조기억장치(디스크)의 스왑 영역으로 쫓아냄
- **스왑 아웃** : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- **스왑 인** : 스왑 영역에 있는 프로세스가 다시 메모리로 옮겨오는 것

**🧠 메모리 내 빈 공간이 여러 개라면 어디에 프로세스를 배치해야 할까?**

<br>

### 📌 연속 메모리 할당

- 프로세스에 연속적인 메모리 공간을 할당
- **고정 분할** : 메모리를 고정 크기의 파티션으로 나누어 각 프로세스를 하나의 파티션에 배치
- **가변 분할** : 각 프로세스에게 자신의 크기만한 크기의 파티션 할당

![image](https://github.com/user-attachments/assets/c14cddfe-9ee3-4f1a-b4cb-77443df40898)


✔ CPU의 메모리 액세스 속도가 빠름

✔ 운영체제가 관리할 정보량이 적어서 부담이 덜함

❌ 고정 분할 - 파티션 크기보다 프로세스가 작아 빈 공간이 생기는 **내부 단편화** 발생

❌ 가변 분할 - 메모리 사이사이에 빈 공간이 생기는 **외부 단편화** 발생

❌ 물리 메모리보다 큰 프로세스를 실행할 수 없음

<br>

### 📌 **불연속 메모리 할당**

- 프로세스를 쪼개서 메모리에 할당하는 방식
- **고정 분할 : 페이징**
- **가변 분할 : 세그멘테이션**

![image](https://github.com/user-attachments/assets/31813c6e-c35d-4b16-bafe-bf8d83a34301)


✔ 메모리 활용도 증가 - 연속된 공간이 없어도 여러 개의 작은 빈 공간을 활용 가능

❌ 불연속적으로 배치되어 다음으로 실행할 페이지를 찾기 어려움

<br>

### 📌 가상 메모리 관리

- 실행하고자 하는 프로그램의 일부만 메모리에 적재해, 실제 메모리보다 더 큰 프로세스를 실행할 수 있도록 함
- 보조기억장치의 일부를 메모리처럼 사용
- 메모리를 실제 크기보다 더 크게 보이게 하는 기술

![image](https://github.com/user-attachments/assets/5fa8d79e-d083-43b3-9720-a740dad57920)

<br>

---

<br>

## 📃 페이징 Paging

- 프로세스의 논리 주소 공간을 **페이지**라는 일정한 단위로 나누고, 물리 주소 공간을 페이지와 동일한 크기의 **프레임**이라는 일정한 단위로 나눈 뒤 페이지를 프레임에 할당하는 **가상 메모리 관리 기법**
- **페이지** : 프로세스의 논리 메모리를 같은 크기의 블록으로 나눈 것
- **프레임** : 물리 메모리를 페이지와 같은 크기의 블록으로 나눈 것

![image](https://github.com/user-attachments/assets/8b9eefe9-14c5-400a-9de0-03ee57dc2926)

<br>

### 🏓 페이징 테이블

- 가상 메모리의 페이지들이 실제 메인 메모리의 어느 프레임에 매핑되는지 기록한 테이블
- 모든 프로세스는 하나의 페이징 테이블을 가지고 있음

![image](https://github.com/user-attachments/assets/987f0c58-9c4d-4328-a1a6-4a75507ac28b)

<br>

✔ **외부 단편화** 없음 - 똑같은 크기로 나눴으므로 외부 단편화가 발생하지 않음

❌ **내부 단편화** 발생 가능 - 마지막 페이지가 채워지지 않을 때 발생할 수 있음

🏠 **주소 변환** : 논리 주소를 물리 주소로 변환하기 위해 페이지 테이블 사용

<br>

---

<br>

## 🍥 세그멘테이션 Segmentation

- 가상 메모리를 서로 크기가 다른 단위로 나누어 관리
- 프로세스를 물리적 단위인 페이지가 아닌, 논리적 단위인 **세그먼트**로 분할하여 할당하는 방식
- **세그먼트** : 프로그램의 논리적인 단위로 각각의 세그먼트는 고유한 크기를 가짐
- **세그먼트 테이블** : 각 세그먼트가 물리 메모리의 어느 위치에 있는지 기록한 테이블

![image](https://github.com/user-attachments/assets/2a558b7b-a17c-41f0-8965-1430c41e5415)

<br>


✔ **내부 단편화** 없음 - 세그먼트는 필요한 크기만큼 할당되므로 내부 단편화가 발생하지 않음

❌ **외부 단편화** 발생 가능 - 세그먼트의 크기가 달라 외부 단편화가 발생할 수 있음

🏠 **주소 변환** : 세그먼트 번호와 오프셋을 사용하여 논리 주소를 물리 주소로 변환

<br>

**🐖 페이징은 돼지를 같은 크기로 잘라서 보관하는 것, 
세그멘테이션은 부위 별로 잘라서 보관하는 것!**

<br>

---

<br>

## 🛟 페이지드 세그멘테이션 Paged Segmentation

- 세그멘테이션과 페이징을 결합한 방식
- 세그먼트는 논리적인 단위로 나뉘어지지만, 각 세그먼트는 다시 페이지로 나뉨
- **세그먼트** : 프로그램의 논리적인 단위로 나뉜 부분
- **페이지** : 각 세그먼트가 다시 동일한 크기의 페이지로 나뉨
- **세그먼트 테이블** : 각 세그먼트의 페이지 테이블을 가리킴
- **페이지 테이블** : 각 페이지가 물리 메모리의 어느 프레임에 매핑되는지 기록한 테이블

![image](https://github.com/user-attachments/assets/30024061-efdb-4ee6-ad48-df988b876db2)

<br>


✔ **내부 단편화** - 마지막 페이지가 채워지지 않을 때 발생할 수 있음

✔ **외부 단편화 감소** - 세그먼트가 페이지로 나뉘어 있어 외부 단편화가 줄어듦

🏠 **주소 변환** : 세그먼트 번호, 페이지 번호, 오프셋을 사용하여 논리 주소를 물리 주소로 변환

<br>

### 🔥 정리

- 연속 할당 방식
    - 고정 분할 - 외부 단편화, 내부 단편화
    - 가변 분할 - 외부 단편화
- 불연속 할당 방식
    - 페이징 (고정 분할) - 내부 단편화
    - 세그멘테이션 (가변 분할) - 외부 단편화
    - 페이지드 세그멘테이션

<br>

---

<br>

## 🧀 페이지 교체 알고리즘

### 📌 OPT (Optimal)

![image](https://github.com/user-attachments/assets/770b5e10-3ee1-4812-bd7d-f555bf036592)

- 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
- 가장 이상적이지만, 프로세스가 앞으로 사용할 페이지를 미리 알아야하므로 불가능
- 비교 연구 목적을 위해 사용

<br>

### 📌 FIFO (First In First Out)

![image](https://github.com/user-attachments/assets/7c43c602-c40e-4d7e-b49c-b7a47a3eed17)



- 가장 먼저 들어온 페이지를 교체


✔ 구현이 간단하고 쉬움!!!



❌ 가장 오래된 페이지가 꼭 덜 중요한 페이지라는 보장은 없음

❌ **벨라디의 모순(Belady’s Anomaly)** – 페이지 프레임을 늘려도 페이지 폴트가 감소하지 않는 현상이 발생할 수 있음

<br>

### 📌 LRU (Least Recently Used)

![image](https://github.com/user-attachments/assets/fc625cbb-ea50-4530-b4b7-91e12e8303f5)



- 가장 오래 사용되지 않은 페이지를 교체
- **시간 지역성** 성질 고려 - 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질



✔ FIFO보다 성능이 좋고, 실용적

✔ 자주 쓰는 페이지는 오래 유지할 확률이 높음



❌ 페이지 사용 시간을 기록해야 해서 **추가적인 오버헤드 발생**

❌ 카운터나 큐, 스택과 같은 별도의 저장 공간 필요

<br>

### 📌 LFU (Least Frequently Used)

![image](https://github.com/user-attachments/assets/8c4e45d9-e6be-4348-bb36-b9517453a145)


- 가장 적게 사용된 페이지를 교체
- 사용 횟수를 기록해서 사용 빈도가 적은 페이지부터 제거


✔ 자주 쓰이는 페이지는 유지되므로 성능이 좋음

✔ 참조횟수를 통해 장기적 시간규모에서의 참조성향을 고려할 수 있음

❌ 새로운 페이지가 들어오면 초반에는 무조건 사용 횟수가 적기 때문에 문제가 발생할 수 있음

❌ 추가적인 저장 공간과 연산이 필요하며, 막대한 오버헤드 발생

<br>

### 📌 MFU (Most Frequently Used)

![image](https://github.com/user-attachments/assets/ab6edfe5-f45c-4811-84a7-92250224cada)


- 참조 횟수가 가장 많은 페이지 교체
- 가장 많이 사용된 페이지가 앞으로는 사용되지 않을 것이라 가정

<br>

### 📌 NRU (Not Recently Used)

![image](https://github.com/user-attachments/assets/fe8e6fb1-9bd8-4253-8b72-b8b3ac2c5075)

- == NRU, NUR, 클럭 알고리즘
- 가장 최근에 사용하지 않은 페이지를 교체한다는 점에서 LRU와 근사하지만, 
교체되는 페이지의 참조 시점이 가장 오래되었다는 것을 보장하지는 않음
- **참조 비트** : 페이지가 참조되었을 때 1
- **변경 비트** : 페이지가 변경되었을 때 1

<br>

**💥 LRU, LFU, NUR 성능은 거의 비슷하며 FIFO보다 우수하다**


**💥 NUR은 2bit만 추가하여 다른 알고리즘과 유사한 성능을 내고, 쉽게 구현할 수 있어 많이 사용**
