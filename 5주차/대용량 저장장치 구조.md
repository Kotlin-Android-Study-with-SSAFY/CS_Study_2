
# 💽 대용량 저장장치


---

## 📌 목차

1. 저장장치란?
2. 디스크의 구조
3. 섹터와 트랙, 그리고 ZBR
4. 디스크 접근 시간
5. 디스크 스케줄링
6. 디스크의 무결성과 복구


---

## 1. 💾 저장장치란?

- 데이터를 **오래 저장하기 위한 장치**
- RAM은 전원이 꺼지면 날아가지만, **디스크(HDD/SSD)는 꺼져도 데이터가 남아있음**
- HDD, SSD, USB, CD/DVD 모두 저장장치

---

## 2. 📀 디스크의 구조
![image](https://github.com/user-attachments/assets/a6125214-e00d-4452-9cf7-d2c31e20827c)

디스크는 **원판(플래터)**에 자성 물질을 입혀  
회전하면서 데이터를 읽고 씁니다.


![image](https://github.com/user-attachments/assets/1dc1b444-d385-47fb-baa4-fc5c2fe92727)


- **트랙 (Track)**: 원판을 도넛 모양으로 나눈 원형 고리
- **섹터 (Sector)**: 트랙을 조각처럼 나눈 조각 (하나당 512B 또는 4KB)
- **플래터**는 여러 개의 트랙을 가짐 → 하드디스크는 수천 개 트랙 존재

📍 비유:
> 트랙 = 도넛의 각 층,  
> 섹터 = 도넛 조각


---

## 3. 📐 섹터는 모두 같은 길이일까?

> **데이터량(512B)은 같지만, 실제 디스크에서 차지하는 물리적 길이(호 길이)는 다릅니다!**

왜?

- 바깥쪽 트랙은 원 둘레가 길기 때문
- 같은 512B를 저장하려면 **더 긴 호의 길이**가 필요함

### 🌀 ZBR(Zone Bit Recording): 이를 해결하는 구조
![image](https://github.com/user-attachments/assets/d57ff510-6cd2-4d53-b83f-99175adecbf9)

- 디스크를 **여러 존(zone)** 으로 나누고
- **바깥쪽 존에는 더 많은 섹터** 를 배치
- 존 안의 모든 트랙은 같은 섹터 수를 가짐

📍 비유:
> 신발을 1mm 단위로 만드는 대신 S, M, L로 구분해 설계 효율과 편의성 모두 챙긴 것과 같음

---
## ⚙️ 4. 디스크 접근 시간
디스크에서 데이터를 읽기 위해 걸리는 시간 구성:

탐색 시간(Seek Time): 헤드가 트랙 위치로 이동하는 시간

회전 지연(Rotational Latency): 섹터가 헤드 아래로 올 때까지 기다리는 시간

전송 시간(Transfer Time): 데이터를 실제로 읽거나 쓰는 시간

전체 디스크 성능의 핵심 = 탐색 시간 + 회전 지연 최소화하기

## 5. ⚙️ 디스크 스케줄링 알고리즘

디스크는 데이터를 읽기 위해 **헤드를 움직여야 하기 때문에**,  
헤드가 움직이는 순서를 **최적으로 조절**하는 것이 중요합니다.  
이를 위해 다양한 디스크 스케줄링 알고리즘이 존재합니다.

---

### 🟢 1) FCFS (First Come First Serve)

> **먼저 요청한 순서대로 처리**하는 방식

- 구현이 간단함
- 하지만 탐색 거리 최적화는 안 됨 → 비효율적

**예시**
- 현재 헤드 위치: `50`
- 요청 순서: `95 → 180 → 34 → 119`
- 처리 경로: `50 → 95 → 180 → 34 → 119`
- 총 이동 거리: 매우 큼

---

### 🟡 2) SSTF (Shortest Seek Time First)

> **가장 가까운 요청부터 처리**하는 방식

- 평균 탐색 시간이 낮음
- 단점: **기아(Starvation)** 가능성 있음  
  (먼 요청은 계속 밀릴 수 있음)

**예시**
- 현재 헤드 위치: `50`
- 요청: `95, 180, 34, 119`
- 처리 경로: `50 → 34 → 95 → 119 → 180`

---

### 🔵 3) SCAN (엘리베이터 알고리즘)

> **엘리베이터처럼 한 방향으로 이동하며** 요청 처리,  
끝까지 갔다가 방향을 바꿔서 반대편도 처리

- 요청 분포가 고르다면 좋은 성능
- **기아 방지 가능**

**예시**
- 현재 헤드 위치: `50`, 이동 방향: 증가
- 요청: `34, 95, 180, 119`
- 처리 경로: `50 → 95 → 119 → 180 → (끝) → 34`

---

### 🟣 4) C-SCAN (Circular SCAN)

> **한 방향으로만 쭉 이동**한 후, 끝에 도달하면  
**가장 처음 트랙으로 이동해서 다시 시작**

- **응답 시간이 고르게 분포**
- **공평한 기회 보장**

**예시**
- 현재 헤드 위치: `50`
- 요청: `34, 95, 119, 180`
- 처리 경로: `50 → 95 → 119 → 180 → (끝) → 0 → 34`

---

### 🟠 5) LOOK / C-LOOK

> SCAN / C-SCAN의 개선형  
> **요청이 있는 마지막 트랙까지만 이동** (끝까지 가지 않음)

- **불필요한 트랙 이동 최소화**
- 실제 요청만 고려하므로 효율적

**LOOK 예시**
- 경로: `50 → 95 → 119 → 180 → 34`

**C-LOOK 예시**
- 경로: `50 → 95 → 119 → 180 → (맨 처음 요청) → 34`

---

### 📊 알고리즘 비교 표
| 알고리즘 | 설명 | 특징 |
|----------|------|------|
| FCFS | 먼저 요청한 순서 | 단순하지만 비효율적 |
| SSTF | 가까운 요청부터 | 평균 성능 좋음, 기아 현상 가능 |
| SCAN | 엘리베이터처럼 이동 | 고른 처리, 양방향 |
| C-SCAN | 한 방향만 돈 뒤 처음으로 회귀 | 일정한 응답 시간 |
| LOOK / C-LOOK | 실제 요청 있는 트랙까지만 이동 | SCAN 개선형 |

---

## 6. 🛡️ 디스크의 무결성과 복구
###  📝 저널링 (Journaling)
### 📝 RAID (Redundant Array of Independent Disks)





