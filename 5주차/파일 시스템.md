## 파일 시스템

### 파일 시스템의 개념

- 컴퓨터 시스템의 다양한 파일은 하드디스크, CD 등의 저장장치에 보관됨.
- 파일 관리자는 저장장치의 전체 파일을 관리하며, **파일 시스템**이라고 함.
- 파일 관리자는 **파일 테이블**을 사용하여 파일의 위치, 크기, 이름 등 정보를 관리.
- 파일 사용 시 **읽기**, **쓰기**, **실행** 등 다양한 접근 방법을 제공하며, 이때 필요한 권한을 **파일 디스크럽터**가 관리.

### 파일 시스템의 기능

- **파일 생성 및 관리:** 사용자가 쉽게 파일을 생성하고 관리할 수 있도록 디렉터리 구조 제공.
- **파일 구분:** 파일 이름과 확장자를 통해 다양한 종류의 파일을 구분.
- **메타데이터 관리:** 파일 이름, 크기, 생성 날짜 등 다양한 정보를 파일 헤더에 기록.
- **보안 및 무결성:** 접근 권한 관리, 접근 방법 제공, 백업/복구, 암호화 기능 제공.

---

## 블록

- 데이터는 운영체제와 저장장치 간에 **블록** 단위로 전송됨.
- 블록은 저장장치에서 사용하는 가장 작은 단위로, 한 블록당 주소가 할당됨.
- 블록 크기는 시스템마다 다르며, 너무 작으면 내부 단편화가 줄어들지만 파일 입출력 속도에는 영향을 줄 수 있음.
- 큰 파일을 다룰 때는 블록 크기를 크게 설정하는 것이 유리함.

---

## 파일

### 파일의 개념

- 파일은 **논리적인 데이터 집합**으로, 하드디스크나 CD와 같은 저장장치에 보관됨.
- 모든 파일은 0과 1의 **비트 패턴**으로 구성되며, 크게 **실행 파일**과 **데이터 파일**로 구분됨.
- 파일의 이름은 `파일이름.확장자` 형식으로 구성됨.

### 실행 파일

- 운영체제가 메모리로 가져와 CPU를 이용해 작업을 수행하는 파일.
- 사용자의 요청에 의해 **프로세스**로 실행됨.

### 데이터 파일

- 실행 파일이 작업하는 데 필요한 데이터를 모아둔 파일.
- 자체적으로 프로세스가 될 수 없으며, 전송되거나 보관되는 용도로 사용됨.
- 예시: 이미지 뷰어의 사진 파일, 뮤직 플레이어의 음악 파일 등.

### 파일 속성

![](https://github.com/workhardslave/cs-study/raw/main/OS/img/File_00.png)

- **name:** 확장자를 포함한 전체 파일 이름.
- **type:** 실행 파일, 동영상 파일, 사진 파일 등 확장자를 통해 구분.
- **size:** 파일 용량.
- **time:** 파일 접근 시간(생성, 변경, 최근 열람 등).
- **location:** 파일의 위치 (같은 디렉터리에 동일한 이름의 파일은 존재 불가).
- **accessibility:** 파일의 접근 권한.
- **owner:** 파일의 소유자 (유닉스에서 주로 사용).

> 각 파일은 운영체제가 관리하는 파일 헤더 외에, 데이터 파일마다 필요한 고유 속성을 정의하는 고유 헤더를 가질 수 있습니다.
> 

---

## 파일 연산

파일 연산은 파일 **자체**를 변경하는 작업과 **파일 내용**을 변경하는 작업으로 구분됨.

### 파일 자체를 변경

![image](https://github.com/user-attachments/assets/45908922-5b27-465a-a0d8-5798a8869b29)

### 파일 내용을 변경

![image](https://github.com/user-attachments/assets/4a207102-9bfa-4355-834a-f1ec20e65ec7)

---

## 파일 구조

### 순차 파일 구조

![image](https://github.com/user-attachments/assets/bb7d73e3-0746-44c1-9e63-9bb575d8e9a3)

- **특징:** 파일 내용이 하나의 긴 줄(선형)로 저장됨.
- **장점:**
    - 모든 데이터가 순차적으로 기록되어 저장 공간 낭비가 없음.
    - 구조가 단순하여 테이프, 플로피디스크, 메모리 등 다양한 저장장치에 적용 가능.
    - 순차적 데이터 읽기/저장이 매우 빠름.
- **단점:**
    - 파일 내 새로운 데이터 삽입 또는 삭제 시 시간이 많이 소요됨.
    - 특정 데이터를 직접 접근하기 어려워 검색에 부적합.

### 인덱스 파일 구조

![image](https://github.com/user-attachments/assets/d4b3c1a4-4638-4dc6-b922-cb001d7cda93)

- **특징:** 인덱스 테이블을 이용하여 순차 접근과 직접 접근이 가능.
- **장점:**
    - 여러 개의 인덱스 테이블로 다양한 접근 방법 제공.
    - 대용량 데이터를 효율적으로 처리.
- **단점:**
    - 인덱스 영역을 저장하기 위한 추가 공간 필요.
    - 인덱스 참조로 인해 직접 접근하는 파일보다 접근 시간이 느림.

### 직접 파일 구조

![image](https://github.com/user-attachments/assets/91434bc5-20be-4ad7-b23e-969eb3482391)

- **특징:** 해시 함수를 이용하여 데이터의 물리적 주소를 바로 변환해 접근.
- **장점:** 해시 함수로 인해 매우 빠른 데이터 접근.
- **단점:**
    - 전체 데이터를 고르게 분포시킬 수 있는 적절한 해시 함수를 찾기 어려움.
    - 잘 설계해도 저장 공간이 낭비될 수 있음.

---

## 디렉터리

### 디렉터리의 개념

- 관련 있는 파일을 하나로 모아놓은 **폴더** 역할.
- 하나 이상의 자식 디렉터리와 파일을 포함할 수 있음.
- 여러 층으로 구성되며, 최상위에는 **루트 디렉터리**가 존재함.

### 디렉터리 파일

![image](https://github.com/user-attachments/assets/793b23dc-842c-4c1a-b691-470e37ee8d6a)

- 디렉터리도 파일의 일종으로, 일반 파일은 데이터가 담기고 디렉터리는 포함된 파일들의 정보가 담김.
- 디렉터리 헤더에는 디렉터리의 이름, 생성 시간, 접근 권한, 실제 내용이 저장된 블록의 위치 등이 기록됨.

### 경로

- **절대 경로:** 루트 디렉터리를 기준으로 파일의 위치를 나타냄
예: `/program/data/exam.c`
- **상대 경로:** 현재 위치를 기준으로 파일의 위치를 표시
예: `data/exam.c`

### 디렉터리 구조

- **1단계 디렉터리 구조**

    ![image](https://github.com/user-attachments/assets/3f828977-3a2a-4e77-8532-599cfc968c34)

    
- **2단계 디렉터리 구조**

    ![image](https://github.com/user-attachments/assets/f90f81ec-c1cc-4af4-906e-8008a1436741)

    
- **트리 디렉터리 구조**

    ![image](https://github.com/user-attachments/assets/da7c4fd7-4ead-477e-924d-04b134809025)

    
- **그래프 디렉터리 구조**

    ![image](https://github.com/user-attachments/assets/072f4009-7e97-427c-b136-2034ece14407)

    

### 마운트

![image](https://github.com/user-attachments/assets/7d48e871-e800-4803-b099-5917a0fc0f3b)

- 여러 개의 파티션을 하나로 통합하는 명령어.
- 사용자는 파티션1과 파티션2가 하나의 파티션으로 인식함.
- 유닉스에서는 `/dev` 아래에 외부 저장장치를 마운트하여 사용.

---

## 디스크 파일 할당

### 연결 할당 방식

![image](https://github.com/user-attachments/assets/48d03503-765f-4c4f-9e43-9acae12aefd6)

- 파일 데이터를 **연결 리스트**로 관리.
- 파일 테이블에는 시작 블록 정보만 저장하고, 나머지 데이터는 시작 블록부터 연결 리스트로 이어짐.
- **단점:** 연결 리스트 관리의 복잡성.

### 파일 테이블을 이용한 불연속 할당

![image](https://github.com/user-attachments/assets/3c2445cc-f52a-406b-b805-5cebe71e87cb)

- 연결 리스트의 포인터 정보를 별도의 테이블에 저장.
- 하나의 파티션이 사용할 수 있는 디스크 용량은 테이블의 주소 크기에 의해 제한됨
예: FAT16은 16비트 주소 → 최대 32GB

### 인덱스를 이용한 불연속 할당

![image](https://github.com/user-attachments/assets/d7e72412-7516-4841-8830-2d9e43949295)

- 데이터 블록의 **인덱스**를 담은 **인덱스 블록(inode)**을 이용하여 파일 데이터를 관리.
- 인덱스 블록은 실제 데이터의 위치 정보를 순차적으로 저장.
- 테이블이 꽉 차면 간접 인덱스 블록을 추가하여 확장 가능하며, 유닉스의 I-node가 이 방식을 사용함.

### 유닉스 I-node

![image](https://github.com/user-attachments/assets/3e1f83bb-7885-4fe7-9d42-aa958e7025d0)

- 파일 크기가 작은 경우 블록을 직접 연결해 빠른 접근이 가능.
- 파일 크기가 큰 경우 인덱스 블록과 간접 포인터를 이용해 확장.

### 빈 공간 리스트

![image](https://github.com/user-attachments/assets/d7b9a1e3-5547-478b-8500-7a900e7f4214)

- 파일이 삭제되면 해당 파일의 블록 정보를 **빈 공간 리스트**에 등록.
- 새로운 데이터를 저장할 때, 삭제된 블록이 아닌 리스트의 맨 앞 블록에 할당됨.
- 이를 통해 디스크의 빈 공간을 효율적으로 관리함.

---

## 접근 제어

![image](https://github.com/user-attachments/assets/23e0bfb6-4ec6-4e67-8f9f-64578a0a4dd7)

- **r (read):** 읽기 권한 – 값 4
- **w (write):** 쓰기 권한 – 값 2
- **x (execute):** 실행 권한 – 값 1
- `chmod` 명령어를 사용하여 파일 및 디렉터리의 접근 권한을 설정함.
