
# 2. IPC (Inter Process Communication) 프로세스 간 통신

IPC(Inter Process Communication)란 **프로세스 간 데이터를 주고받는 통신 방식**입니다. 운영체제에서 각 프로세스는 **독립적인 메모리 공간**을 가지므로 직접 데이터를 공유할 수 없습니다. 하지만 **IPC를 활용하면 프로세스 간 자원과 데이터 교환이 가능**해집니다.

예를 들어, 웹 브라우저의 여러 탭은 각기 독립된 프로세스로 동작하지만, 북마크, 캐시 등 일부 데이터를 공유해야 합니다. 이때 IPC가 활용됩니다.

---
<br>

## 1️⃣ IPC의 필요성

IPC는 다음과 같은 이유로 필수적인 기술입니다:

✔ **프로세스 간 데이터 공유** → 독립적인 프로세스들이 데이터를 교환할 수 있음

✔ **자원 효율적 사용** → 중복된 데이터 저장 방지, 시스템 자원 절약

✔ **병렬 처리 지원** → 다중 프로세스 환경에서 원활한 협업 가능

✔ **네트워크 통신 가능** → 원격 시스템 간의 데이터 교환 가능

<br>
<br>

## 2️⃣ IPC 방식에는 어떤 종류가 있나?

IPC 방식은 크게 
**메시지 전달(Message Passing)** 
과 
**공유 메모리(Shared Memory)** 두 가지로 나눌 수 있습니다.
<br>
<br>
### 📌 1. 메시지 전달 방식 (Message Passing)

메시지 전달 방식은 **프로세스 간 데이터를 메시지 형태로 커널을 통해 송수신하는 방식**입니다. 각 프로세스는 
**자신의 메모리 공간(사용자 영역)**
에서만 데이터를 읽고 쓸 수 있으며, 직접적인 공유가 불가능합니다. 대신, 운영체제가 제공하는 **메시지 큐, 파이프, 소켓** 등의 메커니즘을 통해 데이터를 교환합니다.

✔ **운영체제가 메시지 흐름을 관리**하여 안전성이 높음

✔ **프로세스 간 직접 접근 불가** → 동기화 문제 없음

✔ **속도가 비교적 느림** (커널을 통해 송수신되므로)
<br>
<br>
📌 **메시지 전달 방식의 특징**

- 메시지를 보내는 프로세스와 받는 프로세스가 명확하게 구분됨
- `send()`, `recv()` 같은 시스템 콜을 호출하여 메시지를 송수신
- 커널이 중재하여 공유 메모리 기반 IPC 보다 레이스 컨디션, 동기화 문제를 줄일 수 있음
- 다만, 데이터를 커널을 통해 전송하므로 공유 메모리 방식보다 속도가 느림
<br>

📌 **대표적인 메시지 전달 방식**

![image](https://github.com/user-attachments/assets/3c02b8cd-22d8-4f54-b45e-4f7b4af12fb7)


![image](https://github.com/user-attachments/assets/fc9b24d8-6457-4ae4-a590-eac33dce9db4)


| 방식 | 설명 | 특징 |
| --- | --- | --- |
| **메시지 큐(Message Queue)** | 운영체제가 관리하는 큐를 통해 프로세스 간 메시지를 전달(FIFO로 데이터를 저장했다가 꺼내 쓰는 방식) | 비동기 방식, 대량 데이터 처리 가능,메시지를 큐에 저장, 읽을 때까지 유지 |
| **파이프(Pipes)** | 한 프로세스의 출력 데이터를(쓰기) 다른 프로세스가 입력으로 사용(읽기)하도록 연결, FIFO 구조로 동작 → 먼저 들어온 데이터가 먼저 나감 | 단방향(one-way) 이기 때문에 2개의 파이프를 연결해 양방향 통신 수행,단순한 데이터 스트림을 처리할 때 적합 |
| **시그널(Signal)** | 프로세스 간 이벤트 발생을 알리는 비동기 신호 - 시그널 핸들러를 사용자 정의하여 시그널이 발생했을때 동작으로 통신 | 비동기 이벤트 처리에 적합 (프로세스가 특정 이벤트를 기다리지 않고 자신의 작업을 계속 수행하다가, 시그널이 도착하면 그제야 해당 이벤트를 처리) |
| **소켓(Socket)** | 네트워크를 통해 데이터를 주고받는 IPC 방식 | 원격 프로세스 간 통신 가능 |
| **원격 프로시저 호출(RPC)** | 네트워크를 통해 원격으로 다른 시스템의 함수나 프로시저 실행->결과를 반환받음 | 서버 간 통신 등 분산 시스템에서 주로 사용 |

※ 프로시저(Procedure)는 특정 작업을 수행하는 코드 블록(함수와 유사)
<br>
<br>
<br>
### 📌 2. 공유 메모리 방식 (Shared Memory)

프로세스들이 **특정 메모리 공간을 공유하여 데이터를 직접 주고받는 방식**입니다. 중개자 없이 곧바로 자신의 메모리 영역을 읽고 쓰는 것으로 통신이 가능하기 때문에 속도가 빠르지만, **동기화 문제를 해결해야 합니다.**

✔ **운영체제 개입 최소화** → 속도가 빠름

✔ **프로세스가 직접 접근 가능** → 동기화 문제 발생 가능

✔ **대량 데이터 처리에 적합(파일)**
<br>
<br>
<br>
📌 **대표적인 공유 메모리 방식**

<p align="center">
  <img src="https://github.com/user-attachments/assets/2ee28120-ab15-47a6-9230-9a8bbb6d6b8f" width="45%">
  <img src="https://github.com/user-attachments/assets/8c32db59-8716-450e-a3e1-e5b02828cd2d" width="45%">
</p>


| 방식 | 설명 | 특징 |
| --- | --- | --- |
| **공유 메모리(Shared Memory)** | 특정 메모리 영역을 여러 프로세스가 공유하여 데이터 교환 | 속도가 빠르지만 동기화 필요 |
| **파일 매핑(File Mapping)** | 동일한 파일을 메모리에 매핑하여 데이터 공유 | 대용량 데이터 처리에 유용 |

<br>
<br>
<br>
<br>
👉 메시지 전달 방식은 운영체제가 중재하여 안정적이지만 속도가 느리고, 공유 메모리 방식은 속도가 빠르지만 공유메모리 영역을 동시에 읽고 쓸 경우 동기화 문제가 발생할 수 있습니다(레이스 컨디션).
<br>

---

<br>

### 📌 **익명 파이프 vs 지명 파이프**

| 구분 | 익명 파이프 (Unnamed Pipe) | 지명 파이프 (Named Pipe, FIFO) |
| --- | --- | --- |
| **파일 시스템 등록 여부** | ❌ (파일 시스템에 존재하지 않음) | ✅ (파일 시스템에 FIFO 파일로 생성됨) |
| **통신 가능 범위** | 부모-자식 프로세스 간 | 관계없는 프로세스 간도 가능 |
| **통신 방향** | 단방향(One-Way) | 양방향 가능(하지만 동시에 읽기/쓰기 불가) |
| **읽기/쓰기 방식** | `pipe()` 호출 시 읽기/쓰기 디스크립터 자동 생성 | `open()` 시 읽기/쓰기 모드를 명시적으로 지정해야 함 |
| **전이중(Full-Duplex) 지원** | ❌ (두 개의 파이프 필요) | ❌ (두 개의 파이프 필요) |

> **익명 파이프(unnamed pipe)**
> 는 부모 프로세스와 자식 프로세스 간에만 통신이 가능하며, 단방향으로만 데이터 전송이 가능합니다. (한번 `pipe()` 로 생성된후 읽기 전용 FD(`fd[0]`)와 쓰기 전용 FD(`fd[1]`)이 정해지면 바꿀수없음)
> 
> 
> 
> **지명 파이프(named pipe, FIFO)**
> 는 이름이 지정된 파이프로, 부모-자식 관계가 아닌 프로세스 간에도 통신할 수 있습니다. 양방향 통신이 가능하지만, **읽기/쓰기 동작이 동시에 수행될 수 없으며**, 완전한 전이중(Full-duplex) 통신을 위해서는 2개의 파이프가 필요합니다.
> 
> 파일처럼 동작하므로 읽기/쓰기 모드로 전환하며 열수있지만 `open()`  동시에 읽고 쓰는것은 불가
> 
> (읽기(Read) 작업이 진행 중이면 쓰기(Write)가 블록(대기) 상태가 되고, 반대로 쓰기 중이면 읽기가 블록됨)
> 
> → 그럼 둘다 어차피 두개씩 만들어서 써야 하는건가? 
> 그렇다..
> 

<br>
<br>
<br>

### ✅ 메시지 큐 vs 파이프 : 언제, 왜 파이프를 사용할까?

- 단순한 데이터 스트림 처리에 적합 → 메시지 큐는 데이터를 저장했다가 꺼내 쓰지만, 파이프는 실시간 데이터 흐름을 지원
- 메모리 부담이 적음 → 파이프는 데이터를 (오래) 저장하지 않고 바로 전달, 메시지 큐는 큐에 저장되므로 메모리 사용량 증가 가능
- 구현이 간단함 → 파이프는 단순하게 읽고 쓰기로 사용 가능하지만, 메시지 큐는 생성·관리 과정이 필요
- 운영체제 기본 지원 → 파이프는 대부분의 운영체제에서 기본적으로 제공되며, 추가 설정 없이 사용 가능
  
  <br>
  
🐙단순한 데이터 스트림 처리나 실시간 데이터 전송이 필요한 경우 파이프를 사용하는 것이 적합하며, 데이터의 보관이나 비동기 처리가 필요한 경우 메시지 큐를 사용하는 것이 바람직합니다.🐙

<br>
<br>
<br>

### ❓읽던 중에 파이프 방향을 바꾸면 내부 데이터가 역류할까?
>

✔ 역류하지 않습니다!

✔ 하지만, 읽던 중에 방향을 전환하면 아직 읽지 않은 데이터가 손실될 수 있음



✔ 파이프 내부에는 FIFO 구조의 큐가 존재하여 데이터가 순차적으로 쌓입니다.

✔ 파이프의 방향을 바꾸려면 반드시 파이프를 닫아야 하므로 내부 데이터가 초기화됩니다.

✔ 이 과정에서 읽지 않은 데이터는 손실되지만, 역류하지는 않습니다.
<br>
<br>
<br>
