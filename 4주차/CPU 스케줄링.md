---

### 📌 CPU 스케줄링

단일 프로세서 시스템에서는 한 번에 하나의 프로세스만 실행될 수 있다. 하지만 여러 개의 프로세스가 동시에 실행되기를 원하므로, 운영체제는 CPU를 효율적으로 배분하는 **CPU 스케줄링**을 수행해야 한다.

---

## 📍 프로세스 스케줄링이란?

프로세스는 보통 **CPU 실행**과 **I/O 작업**을 반복한다.  
I/O 작업을 수행하는 동안에는 CPU를 사용하지 않으므로, 다른 프로세스에게 CPU를 할당하면 효율성을 높일 수 있다.  
즉, **CPU 스케줄링은 여러 프로세스를 효과적으로 관리하여 CPU 이용률을 극대화하는 기법**이다.

### ✅ 스케줄링의 목표
- **CPU 이용률 (CPU Utilization) 증가**: CPU가 유휴 상태로 있는 시간을 최소화
- **처리율 (Throughput) 향상**: 단위 시간당 처리할 수 있는 프로세스 수 증가
- **응답 시간 (Response Time) 단축**: 사용자 요청에 대한 첫 응답 시간 단축
- **공정성 (Fairness) 보장**: 특정 프로세스가 과도하게 기다리지 않도록 함

---

## 📍 프로세스 상태 (Process States)

CPU 스케줄링은 프로세스의 상태 변화에 따라 발생한다.  
프로세스는 **다음 5가지 상태** 중 하나를 가진다.

| 상태 | 설명 |
|------|------|
| **생성 (New)** | 프로세스가 생성 중인 상태 |
| **준비 (Ready)** | CPU 실행을 기다리는 상태 |
| **실행 (Running)** | CPU에서 실행 중인 상태 |
| **대기 (Waiting)** | I/O 작업 등 이벤트를 기다리는 상태 |
| **종료 (Terminated)** | 프로세스 실행이 완료된 상태 |

---

## 📍 프로세스 스케줄링이 발생하는 시점

운영체제는 다음 네 가지 경우에 CPU 스케줄링을 수행할 수 있다.

1. **프로세스가 실행 상태 → 대기 상태로 전환**  
   (예: I/O 요청을 수행할 때)

2. **프로세스가 실행 상태 → 준비 상태로 전환**  
   (예: 더 높은 우선순위의 프로세스가 등장했을 때)

3. **프로세스가 대기 상태 → 준비 상태로 전환**  
   (예: I/O 작업이 완료되었을 때)

4. **프로세스가 종료될 때**  
   (예: 실행이 완료되거나 강제 종료되었을 때)

---

## 📍 선점형 vs 비선점형 스케줄링

| 구분 | 설명 |
|------|------|
| **비선점형 (Non-Preemptive) 스케줄링** | 한 프로세스가 CPU를 할당받으면, 스스로 종료하거나 I/O 요청으로 대기 상태가 될 때까지 CPU를 점유함 (예: FCFS, SJF) |
| **선점형 (Preemptive) 스케줄링** | 실행 중이던 프로세스가 CPU를 점유하고 있더라도, 더 높은 우선순위를 가진 프로세스가 등장하면 CPU를 빼앗김 (예: SRTF, RR, 우선순위 스케줄링) |

- **비선점형**: 문맥 교환(Context Switching) 비용이 적지만 긴급한 작업 처리에 불리함.
- **선점형**: 긴급한 프로세스를 빠르게 실행할 수 있지만 문맥 교환 비용이 증가함.

---

## 📍 스케줄링 성능 평가 지표

| 지표 | 설명 |
|------|------|
| **CPU 이용률 (CPU Utilization)** | CPU가 유휴 상태로 있는 시간을 최소화하는 비율 |
| **처리율 (Throughput)** | 단위 시간당 완료된 프로세스 수 |
| **소요 시간 (Turnaround Time)** | 프로세스가 요청된 후 종료될 때까지 걸린 총 시간 |
| **대기 시간 (Waiting Time)** | 준비 큐에서 대기한 총 시간 |
| **반응 시간 (Response Time)** | 첫 번째 응답이 나오기까지 걸린 시간 |

---

# 🚀 CPU 스케줄링 알고리즘

## ✅ 비선점형 스케줄링 (Non-Preemptive Scheduling)

### 1️⃣ FCFS (First Come First Serve, 선입선출)

- **도착한 순서대로 CPU를 할당하는 방식**  
- **장점**: 단순하고 공정함  
- **단점**: 실행 시간이 긴 프로세스가 먼저 오면 **Convoy Effect(호위 효과)** 발생  
- **구현**: 큐(Queue) 자료구조 사용

---

### 2️⃣ SJF (Shortest Job First, 최단 작업 우선)

- **실행 시간이 가장 짧은 프로세스를 먼저 실행하는 방식**  
- **장점**: 평균 대기 시간을 최소화할 수 있음  
- **단점**: 실행 시간이 긴 프로세스가 계속 밀려나 **기아 현상(Starvation)** 발생 가능  
- **우선순위 기반**: 실행 시간이 짧을수록 높은 우선순위

---

## ✅ 선점형 스케줄링 (Preemptive Scheduling)

### 3️⃣ SRTF (Shortest Remaining Time First, 최단 잔여 시간 우선)

- **SJF와 유사하지만, 더 짧은 실행 시간이 예상되는 프로세스가 등장하면 CPU를 양보하는 방식**  
- **단점**: 문맥 교환(Context Switching) 비용 증가

---

### 4️⃣ 우선순위 스케줄링 (Priority Scheduling)

- **각 프로세스에 우선순위를 부여하여 높은 우선순위를 가진 프로세스부터 실행**  
- **비선점형과 선점형 두 가지 방식이 존재**  
- **단점**: 낮은 우선순위를 가진 프로세스는 계속 실행되지 못하는 **기아 현상(Starvation)** 발생 가능  
- **해결 방법**: **노화(Aging) 기법** 사용하여 시간이 지나면 우선순위를 증가

---

### 5️⃣ RR (Round Robin, 라운드 로빈)

- **시간 할당량(Time Quantum)을 정해 두고, 프로세스를 일정 시간만 실행한 후 다음 프로세스로 교체**  
- **장점**: 짧은 응답 시간 보장, 공정한 CPU 분배  
- **단점**: 시간 할당량이 너무 작으면 문맥 교환이 많아져 오버헤드 증가  

---

# 🚀 CPU 스케줄링 알고리즘 예제

다음 프로세스를 예제로 사용.

| 프로세스 | 도착 시간 | 실행 시간 |
|---------|---------|---------|
| P1      | 0      | 5      |
| P2      | 1      | 3      |
| P3      | 2      | 8      |
| P4      | 3      | 6      |

---

## ✅ 1. FCFS (First Come First Serve) - 선입선출

- **도착한 순서대로 CPU를 할당하는 방식**  
- **비선점형** 스케줄링  
- **단점**: 실행 시간이 긴 프로세스가 먼저 오면 Convoy Effect 발생  

### 📌 Gantt 차트
```plaintext
| P1 | P1 | P1 | P1 | P1 | P2 | P2 | P2 | P3 | P3 | P3 | P3 | P3 | P3 | P3 | P3 | P4 | P4 | P4 | P4 | P4 | P4 |
0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20   21
```

### 📌 평균 대기 시간 계산
```plaintext
P1: 0 - 0 = 0
P2: 5 - 1 = 4
P3: 8 - 2 = 6
P4: 16 - 3 = 13
평균 대기 시간 = (0 + 4 + 6 + 13) / 4 = 5.75
```

---

## ✅ 2. SJF (Shortest Job First) - 최단 작업 우선

- **실행 시간이 가장 짧은 프로세스를 먼저 실행**  
- **비선점형** 스케줄링  
- **단점**: 긴 프로세스는 계속 밀려 기아(Starvation) 현상 발생 가능  

### 📌 Gantt 차트
```plaintext
| P2 | P2 | P2 | P1 | P1 | P1 | P1 | P1 | P4 | P4 | P4 | P4 | P4 | P4 | P3 | P3 | P3 | P3 | P3 | P3 | P3 | P3 |
1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20   21   22
```

### 📌 평균 대기 시간 계산
```plaintext
P1: 3 - 0 = 3
P2: 0 - 1 = 0
P3: 14 - 2 = 12
P4: 8 - 3 = 5
평균 대기 시간 = (3 + 0 + 12 + 5) / 4 = 5
```

---

## ✅ 3. SRTF (Shortest Remaining Time First) - 최단 잔여 시간 우선

- **현재 실행 중인 프로세스보다 더 짧은 실행 시간이 있는 프로세스가 등장하면 교체**  
- **선점형** 스케줄링  
- **단점**: 문맥 교환(Context Switching) 비용 증가  

### 📌 Gantt 차트
```plaintext
| P1 | P2 | P2 | P2 | P1 | P1 | P1 | P1 | P4 | P4 | P4 | P4 | P4 | P4 | P3 | P3 | P3 | P3 | P3 | P3 | P3 | P3 |
0    1    2    3    4    5    6    7    8   9   10   11   12   13   14   15   16   17   18   19   20   21
```

### 📌 평균 대기 시간 계산
```plaintext
P1: 4 - 0 = 4
P2: 1 - 1 = 0
P3: 14 - 2 = 12
P4: 8 - 3 = 5
평균 대기 시간 = (4 + 0 + 12 + 5) / 4 = 5.25
```

---

## ✅ 4. Priority Scheduling (우선순위 스케줄링)

- **우선순위가 높은 프로세스를 먼저 실행**  
- **비선점형 or 선점형 모두 가능**  
- **단점**: 낮은 우선순위를 가진 프로세스는 계속 밀려날 수 있음 (기아 현상)  

> **예제**: 프로세스에 우선순위를 부여하자. (작을수록 우선순위 높음)

| 프로세스 | 도착 시간 | 실행 시간 | 우선순위 |
|---------|---------|---------|---------|
| P1      | 0      | 5      | 3       |
| P2      | 1      | 3      | 1       |
| P3      | 2      | 8      | 4       |
| P4      | 3      | 6      | 2       |

### 📌 Gantt 차트 (비선점형)
```plaintext
| P2 | P2 | P2 | P4 | P4 | P4 | P4 | P4 | P4 | P1 | P1 | P1 | P1 | P1 | P3 | P3 | P3 | P3 | P3 | P3 | P3 | P3 |
1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20   21   22
```

---

## ✅ 5. RR (Round Robin) - 라운드 로빈

- **시간 할당량(Time Quantum)만큼 실행하고, 다음 프로세스로 교체**  
- **선점형** 스케줄링  
- **장점**: 공정한 CPU 분배, 응답 시간 단축  
- **단점**: 시간 할당량이 너무 작으면 문맥 교환이 많아져 오버헤드 증가  

> **시간 할당량 (Time Quantum) = 4**  

### 📌 Gantt 차트
```plaintext
| P1 | P1 | P1 | P1 | P2 | P2 | P2 | P3 | P3 | P3 | P3 | P4 | P4 | P4 | P4 | P1 | P1 | P3 | P3 | P3 | P3 | P4 | P4 | P3 | P3 |
0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24
```

---
