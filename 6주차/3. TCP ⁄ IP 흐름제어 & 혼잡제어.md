# 3. TCP 흐름제어 & 혼잡제어&#x20;

 <br>
 
TCP는 인터넷 환경에서 데이터의 **신뢰성 있는 연결형 전송**을 보장하는 대표적인 프로토콜입니다.\
이 신뢰성 보장을 위해 흐름제어와 혼잡제어라는 제어 메커니즘을 제공합니다.\
이 둘은 각각 **수신 측의 안정성 보장**과 **네트워크 과부하 방지**를 목적으로 하며, 자주 비교 대상이 되기 때문에 명확히 구분하고 있어야 합니다.

 <br>
 
---

## 1️⃣ 흐름제어(Flow Control)란?

### 📌 무엇을 제어하는가?

흐름제어는 **수신 측의 처리 능력을 초과하지 않도록 송신 측의 데이터 전송 속도를 조절**하는 기술입니다.\
즉, 수신자가 과도한 데이터를 한 번에 받지 않도록 제어하여 
**수신 버퍼 오버플로우(overflow)**
를 방지합니다.

- 송신 속도가 너무 빠르면 수신 측은 데이터 처리 중 일부를 유실할 수 있음

 <br>
  <br>
   

### 📌 어떻게 동작하는가?

- 수신 측은 자신의 수신 버퍼의 현재 상태(여유 공간 크기)를 송신 측에 계속 알림(TCP 헤더에 윈도우 필드)
- 송신 측은 수신자가 알려준
- **수신 윈도우(Receive Window, RWND)**
  의 범위 내에서만 데이터를 전송함
  <br>
   <br>
   
 ### ✅ 대표 흐름제어 방식

  Stop-and-Wait: 패킷 하나 보낼 때마다 ACK(확인 응답)를 기다림 → 느림

  Sliding Window: 연속적으로 여러 개 전송 가능, ACK 도착 시 윈도우 이동
 <br>
  <br>
  
  


## 📘 슬라이딩 윈도우란?

슬라이딩 윈도우(Sliding Window)는 윈도우의 범위를 유동적으로 이동하여, 송신자는 
**확인 응답이 도착하지 않은 구간만큼을 고려하여** 데이터를 전송하게 됩니다. 이는 단순히 전송을 멈추고 기다리는 방식이 아니라, 송신자가 여러 개의 세그먼트를 **연속해서 전송**이 가능한 구조로 되어 있습니다.

![image](https://github.com/user-attachments/assets/ae4ffe41-1ba5-45ee-8479-9e337edc8c69)


- 윈도우는 한 번에 전송 가능한 데이터의 범위를 의미합니다.

- 이 범위 안에 있는 데이터는 **ACK: 긍정 응답(Acknowledgement) 없이도 전송 가능**하며,

- ACK가 도착하면 윈도우는 해당 확인 응답 위치까지 **'슬라이딩' 되어 앞으로 이동**합니다.

- 공식: LastByteSent - LastByteAcked <= RWND\
  (마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 남아있는 공간) == (현재 공중에 떠있는 패킷 수 <= sliding window)



✔️ 예시:

- 동작방식 : 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송

* 현재 윈도우 범위가 100\~109 바이트라면, 송신자는 해당 범위 내 데이터를 전송할 수 있습니다.

- 수신자로부터 105까지 ACK가 도착하면 윈도우는 106\~115로 이동하여 그 다음 데이터를 보낼 수 있게 됩니다.



### 💡 핵심 키워드

- 수신 버퍼 (Receive Buffer)
- 수신 윈도우(RWND) 필드
- 슬라이딩 윈도우
 <br>
  <br>
 
---
 
 <br>
 
## 2️⃣ 혼잡제어(Congestion Control)란?

### 📌 무엇을 제어하는가?

혼잡제어는 **네트워크 전체의 처리 용량을 초과하지 않도록 전송량을 조절**하는 기술입니다.\
즉, 너무 많은 트래픽이 네트워크에 몰려서 생기는 
**혼잡 상태(Congestion)**
를 방지합니다.

- 네트워크 혼잡 발생 시 패킷 손실, 지연 증가, 재전송 증가 등 비효율 발생

 <br>
  <br>

### 📌 어떻게 동작하는가?

- 혼잡 윈도우(Congestion Window, CWND)는 **송신 측에서** 자체적으로 관리하는 전송량 제한 변수

- \= 혼잡 없이 전송할 수 있을 정도의 양

- 결국 전송 가능량은 `min(RWND, CWND)`로 결정되며, **둘 중 작은 값을 기준으로 전송함**

- RWND 값은 수신 호스트가 TCP 헤더로 알려주지만, CWND는 송신 호스트가 직접 계산해서 알아내야 함 -> 혼잡제어 알고리즘

 <br>
  <br>

### ✅ 혼잡 감지 방법

- **중복 ACK 3회 수신**: 특정 세그먼트가 유실되었음을 의미 → Fast Retransmit 수행
- **타임아웃 발생**: 지정 시간 안에 ACK를 받지 못함 → 패킷 유실로 판단, 재전송 (RTT 측정)
   <br>
    <br>

### ✅ 대표 혼잡제어 알고리즘 (AIMD 기반)

![image](https://github.com/user-attachments/assets/9eb17966-1a50-4298-8a1e-d3b6828558fe)


1. 혼잡이 감지되지 않으면 혼잡 윈도우 크기를 **RTT마다** 선형적으로 1씩 증가

2. **혼잡이 감지되면** 윈도우를 절반 줄인 후 다시 선형 증가 시작 (AIMD 동작)


   ※ RTT: 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간

 <br>
  <br>
  
### 💡 혼잡제어 키워드

- 혼잡 윈도우(CWND)
- RTT(Round Trip Time), 지연시간 측정
- AIMD (Additive Increase / Multiplicative Decrease, 합으로 증가, 곱으로 감소)
- 패킷 유실 = 혼잡 판단 신호

   <br>
    <br>

---

 <br>

## 3️⃣ 흐름제어 vs 혼잡제어 비교 정리

| 항목        | 흐름제어(Flow Control) | 혼잡제어(Congestion Control) |
| --------- | ------------------ | ------------------------ |
| **목적**    | 수신 버퍼 오버플로우 방지     | 네트워크 전체의 과부하 방지          |
| **제어 기준** | 수신 버퍼(RWND) 상태     | 혼잡 윈도우(CWND), RTT 등 추정   |
| **대상 범위** | 송신자 ↔ 수신자          | 송신자 ↔ 라우터 등 전체 네트워크      |
| **제어 방법** | 슬라이딩 윈도우 기반        | AIMD 기반 혼잡 윈도우 조절        |
| **제어 주체** | 수신 측이 정보 제공        | 송신 측이 스스로 제어 수행          |
|           |                    |                          |

---

## 4️⃣ 흐름제어 & 혼잡제어 동작 흐름

### 🧠 흐름제어 핵심 흐름

- 수신 측은 RWND를 이용해 여유 버퍼 크기를 송신 측에 전달
- 송신 측은 RWND 값만큼만 데이터를 보내고, 확인 응답(ACK)에 따라 윈도우 이동

### 🧠 혼잡제어 핵심 흐름

- 초기에는 느리게 시작(Slow Start), 혼잡 없음 확인되면 윈도우 증가
- 혼잡 발생(ACK 지연/중복/타임아웃) 시 윈도우 크기 감소
- 혼잡 윈도우 변화:

```
혼잡 없음  → CWND += 1 (선형 증가)
혼잡 발생  → CWND /= 2 (감소)
```
